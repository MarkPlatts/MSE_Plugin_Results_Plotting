{
    "collab_server" : "",
    "contents" : "#library(dplyr)\nlibrary(reshape2)\nlibrary(dtplyr)\nlibrary(dplyr)\nlibrary(data.table)\n\ncountColsWithVals = function(file.name, ncols_no_vals, lines.to.skip){\n  file.to.inspect = read.csv(file.name, skip=lines.to.skip)\n  nCols = ncol(file.to.inspect)-ncols_no_vals\n  return(nCols)\n}\n\n#\n#rename columns for timesteps\nrename_timesteps = function(dt, colstart, yearstart){\n  number.of.columns = ncol(dt)\n  names(dt)[colstart:number.of.columns] = 1:(number.of.columns-colstart+1)\n  return(dt)\n}\n\n\nLoadFile_ContainsListStrings = function(Dir.Path, StringsInFileName)\n#Loads the file in folder specified containing all the strings in vector of strings\n{\n  browser()\n  #Get a list of all the files\n  AllFiles <- list.files(Dir.Path)\n  #Need to loop across all files so that we can extract\n  for (iFile in AllFiles){\n    #Find and load file that contains values for selected group and fleet\n    FoundFile = StringContains_AllStrings(ContainingString=iFile, MultipleStrings2Check=StringsInFileName)\n    if(FoundFile) {\n      iFile.data <- read.csv(paste(Dir.Path,iFile, sep=''),skip=7, head=T)\n      return (iFile.data)\n    }\n  }\n  return(NA)\n  \n}\n\n\ngroupsWithHcr = function(hcr.folders, groups.for.f.or.biomass){\n  #compiles a list of all the unique groups with a hcr in the location of folders  \n\n  hcr.file.list = list.files(hcr.folders, full.names = TRUE)\n  \n  groups.list = vector()\n  for(iFile in hcr.file.list){\n    dt = fread(iFile, skip=1, header=T)\n    if(groups.for.f.or.biomass==\"f\") groups.list = c(groups.list, dt$GroupNameForF)\n    if(groups.for.f.or.biomass==\"biomass\") groups.list = c(groups.list, dt$GroupNameForBiomass)\n  }\n  \n  groups.unique.in.hcrs = unique(groups.list)\n  \n  return(groups.unique.in.hcrs)\n  \n}\n\n\ngetStrategyTable = function(hcr.folders){\n  #load up all the hcrs into memory so that we can access and use the values when comparing with realised F's\n\n  #compile a vector with the filenames and associated paths for all hcr files\n  hcr.file.list = list.files(hcr.folders, full.names = TRUE)\n  \n  strategies = data.table()\n  \n  for(iStrategy in hcr.file.list){\n    #get strategy name and the hcrs it contains\n    strategy.name = sub(pattern = \"(.*)\\\\..*$\", replacement = \"\\\\1\", basename(iStrategy))\n    strategy.name = gsub(\"_hcr\", \"\", strategy.name)\n    strategy.table = fread(iStrategy, skip=1, header=T)\n    \n    #create table from strategy name and hcrs and append to overall strategies data.table\n    strategy.table = appendVariableToDataTable(strategy.table, strategy.name, variablename = \"StrategyName\", beg=TRUE, end=FALSE)\n    strategies = rbind(strategies, strategy.table)\n  }\n  \n  return (strategies)\n  \n}\n\n\nappendVariableToDataTable = function(dt, variable, variablename, beg, end){\n  #append a single value to a column either before the first column or after the last depending on whether beg or end is TRUE\n  \n  nrows.table = dim(dt)[1]\n  if(beg) dt.appended = cbind(data.table(x = rep(variable, nrows.table)), dt)\n  if(end) dt.appended = cbind(dt, data.table(x = rep(variable, nrows.table)))\n  names(dt.appended)[names(dt.appended) == \"x\"] = variablename\n  \n  return(dt.appended)\n}\n\n\nisNotAll = function(dt, col.data.starts, val.to.check)\n  #count how many values aren't NA and if there is at least one then return that file is valid\n{\n\n  data.only = dt[, col.data.starts:ncol(dt)]\n  file.valid = FALSE\n  if(sum(data.only!=val.to.check)>0) {file.valid = TRUE}\n  return (file.valid)\n}\n\nisAll = function(dt, col.data.starts, val.to.check){\n  return(!isNotAll(dt, col.data.starts, val.to.check))\n}\n\nGetiYearCatch = function(dt, iYear, ncols.before.timeseries){\n  \n  #load the quota\n  dt.melted = melt(dt, id=names(dt)[1:ncols.before.timeseries])\n  \n  #change name of columns to be more relevant\n  names(dt.melted)[names(dt.melted)==\"variable\"] = \"TimeStep\"\n  names(dt.melted)[names(dt.melted)==\"value\"] = paste(\"Year\", iYear, sep=\"\")\n  \n  #Change type of column\n  dt.melted$TimeStep = as.numeric(dt.melted$TimeStep)\n  \n  #find the maximum timestep\n  #nTimeSteps = max(dt.melted$TimeStep)\n  \n  #filter for iYear\n  dt.melted = dt.melted[TimeStep==iYear]\n  # #calc sum by strategy\n  # if(function.type==1){\n  #   dt.Last5YearSum.byStrategy = dt.melted[,.(Last5YearSum=sum(value)), by=.(StrategyName,ModelID)]\n  # } else if(function.type==2){\n  #   dt.Last5YearSum.byStrategy = dt.melted[,.(Last5YearSum=mean(value)), by=.(StrategyName,ModelID)]\n  # }\n  dt.melted[, TimeStep:=NULL]\n  \n  #change the name of the column to one specified in params so that when we merge two tables\n  #we have column names that refer to data that the last 5 year mean was calculated for\n  #names(dt.Last5YearSum.byStrategy)[names(dt.Last5YearSum.byStrategy)==\"Last5YearSum\"] = val.col.name\n  \n  #return(dt.Last5YearSum.byStrategy)\n  return(dt.melted)\n  \n}\n\n\ncalcLast5Year = function(dt, val.col.name, ncols.before.timeseries, function.type)\n  #outputs as a table the total catch or landings for the last 5 years\n  # ncols.before.timeseries is the number of columns with information such as group strategy modelID prior \n  #to the values in the time series\n  #if function.type == 1 then sum, if function.type == 2 then mean\n{\n\n  #load the quota\n  dt.melted = melt(dt, id=names(dt)[1:ncols.before.timeseries])\n  \n  #change name of timestep column to be more relevant\n  names(dt.melted)[names(dt.melted)==\"variable\"] = \"TimeStep\"\n  \n  #Change type of column\n  dt.melted$TimeStep = as.numeric(dt.melted$TimeStep)\n  \n  #find the maximum timestep\n  nTimeSteps = max(dt.melted$TimeStep)\n  \n  #filter out the last 5 years\n  dt.melted = dt.melted[TimeStep>nTimeSteps-5]\n  #calc sum by strategy\n  if(function.type==1){\n    dt.Last5YearSum.byStrategy = dt.melted[,.(Last5YearSum=sum(value)), by=.(StrategyName,ModelID)]\n  } else if(function.type==2){\n    dt.Last5YearSum.byStrategy = dt.melted[,.(Last5YearSum=mean(value)), by=.(StrategyName,ModelID)]\n  }\n\n  #change the name of the column to one specified in params so that when we merge two tables\n  #we have column names that refer to data that the last 5 year mean was calculated for\n  names(dt.Last5YearSum.byStrategy)[names(dt.Last5YearSum.byStrategy)==\"Last5YearSum\"] = val.col.name\n  \n  return(dt.Last5YearSum.byStrategy)\n  \n}\n\ninitialise_plotting_params = function(folder.name, plot.each.timestep, start.run.year, end.run.year, root.path){\n  #init plotting params\n  plotting_params = list()\n  \n  #Create a vector of x vals at either yearly or monthly intervals\n  plotting_params$TimeStepVals = get_timestep_vals(plot.each.timestep, start.run.year, end.run.year)\n  \n  #get a list of all the files in the Biomass folder\n  plotting_params$g <- list.files(paste(root.path,\"\\\\\",folder.name, sep=''))\n  \n  return(plotting_params)\n}\n\nCreateFolderIfDoesntExist = function(folder.name, path){\n  dir2create = paste(path, folder.name, sep=\"\")\n  if(!dir.exists(dir2create)){\n    dir.create(dir2create)\n  }\n}\n\n# calculating the upper and lower confidence intervals and median ---------\ncalc_vals_for_plotting = function(params, plotting_params){\n  \n  plotting_params$MDNS<- plotting_params$LOWS<- plotting_params$UPPS<- plotting_params$MEANS<- data.frame(year=plotting_params$TimeStepVals,row.names =plotting_params$TimeStepVals)\n  for(strat_i in 1:length(params$strats)){\n\n    STRAT<-paste(params$strats[strat_i],sep=' ')\n    \n    #select subset of data\n    data2plot<- plotting_params$dat[plotting_params$dat$Strategy %in% STRAT,5:ncol(plotting_params$dat)]\n    \n    #quantiles for polygon plot\n    perc<-apply(data2plot,2, FUN=function(x){quantile(x,probs=c(0.025,0.5,0.975),na.rm=T)})\n    perc<-rbind(perc, apply(data2plot,2, FUN=mean) )\n    \n    #save percs\n    plotting_params$LOWS<- cbind(plotting_params$LOWS,perc[1,]);   names(plotting_params$LOWS)[ncol(plotting_params$LOWS)]<-STRAT\n    plotting_params$MDNS<- cbind(plotting_params$MDNS,perc[2,]);   names(plotting_params$MDNS)[ncol(plotting_params$MDNS)]<-STRAT\n    plotting_params$UPPS<- cbind(plotting_params$UPPS,perc[3,]);   names(plotting_params$UPPS)[ncol(plotting_params$UPPS)]<-STRAT\n    plotting_params$MEANS<- cbind(plotting_params$MEANS,perc[4,]); names(plotting_params$MEANS)[ncol(plotting_params$MEANS)]<-STRAT\n\n  }\n  \n  return(plotting_params)\n  \n}\n\n#Create a list of user selected strategies ---------------------------------\ncreate_list_strategies = function(Path2ResultsCSV)\n{\n  path_and_filename = paste(Path2ResultsCSV, \"Results.csv\", sep='')\n  results<-read.table(path_and_filename,sep=',',skip=8,col.names=c(\"Model\",\"Strategy\",\"GroupID\",\"GroupName\",\"Variable\",\"Value\"), fill=T)\n  results<-results[results$Strategy!=\"Z\",]#odd one in _SR_final\n  strats <- as.character(unique(results$Strategy))  # 10/15 strategies\n  vector_of_strats = vector()\n  repeat {\n    print(strats)\n    nstrats = length(strats)\n    keypress = readline(\"Press index number for strategy to add to array or e to end\")\n    if(keypress == \"e\") break\n    keypress = strtoi(keypress) # convert to integer so we can check whether in range of indices for strategies\n    if(keypress >= 1 & keypress <= nstrats){\n      vector_of_strats = c(vector_of_strats, strats[keypress])\n    }\n  }\n  return(vector_of_strats)\n  \n}\n\n\n# Calculate all the x-values for plotting ---------------------------------\nget_timestep_vals = function(plotmonthly, start_year, end_year){\n  if (plotmonthly){\n    xvals=seq(start_year,end_year-1/12,1/12)\n  } else {\n    xvals = start_year:(end_year-1)\n  }\n}\n\nLoadUniqueStrategies = function(path){\n  \n  file.path = paste(path,\"/ValueTrajectories/ValueYearly_AllGroups_FleetNo8.csv\", sep=\"\")\n  file.data = read.csv(file.path, skip=7, header = TRUE)\n  UniqueStrategies = as.vector(as.matrix(unique(file.data$StrategyName)))\n  return(UniqueStrategies)\n  \n}\n\nLoadUniqueGroups = function(path){\n  if(file.exists(paste(path,\"UniqueGroups.csv\",sep=\"\"))){\n    UniqueGroups = as.matrix(read.csv(paste(path,\"UniqueGroups.csv\", sep=\"\"),header = T))\n  } else {\n    file.path = paste(path,\"/Results.csv\", sep=\"\")\n    file.data = read.csv(file.path, skip=7, header = TRUE)\n    file.data = filter(file.data, ResultName == \"BiomassMin\")\n    UniqueGroups = as.vector(as.matrix(unique(file.data$GroupName)))\n    write.csv(UniqueGroups,paste(path,\"UniqueGroups.csv\",sep=\"\"), row.names = F)\n  }\n  return(UniqueGroups)\n}\n\nLoadUniqueFleets = function(path){\n  if(file.exists(paste(path,\"UniqueFleets.csv\",sep=\"\"))){\n    UniqueFleets = as.matrix(read.csv(paste(path,\"UniqueFleets.csv\", sep=\"\"),header = T))\n  } else {\n    file.path = paste(path,\"/Fleet.csv\", sep=\"\")\n    file.data = read.csv(file.path, skip=7, header = TRUE)\n    #file.data = filter(file.data, ResultName == \"BiomassMin\")\n    UniqueFleets = as.vector(as.matrix(unique(file.data$FleetName)))\n    write.csv(UniqueFleets,paste(path,\"UniqueFleets.csv\",sep=\"\"), row.names = F)\n  }\n  return(UniqueFleets)\n}\n\nSubsetVectorStrings_ContainingString = function(VectorStrings, String2Find)\n{\n  SubsetIndices = grep(String2Find, VectorStrings, fixed=TRUE)\n  return(VectorStrings[SubsetIndices])\n}\n\n#Checks whether the filename given is incorrect given setting to either plot yearly or none yearly values\nIsIncorrectFileType_YearlyMonthly = function(FileName, plot_yearly){\n  \n  \n  if(length(grep(\"Yearly\", FileName, fixed=TRUE))>0 & !plot_yearly) return(TRUE)\n  if(length(grep(\"Yearly\", FileName, fixed=TRUE))==0 & plot_yearly) return(TRUE)\n  return(FALSE)\n\n}\n\n\n#Find a string within another string\n#This can be done in a single line but it is fairly unreadable\nStringContains = function(ContainingString, String2Check)\n{\n  return(length(grep(String2Check, ContainingString, fixed=TRUE))>0)\n}\n\n\n#Check that multiple strings all exist within another string\nStringContains_AllStrings = function(ContainingString, MultipleStrings2Check)\n{\n  for(iString in MultipleStrings2Check){\n    if(StringContains(ContainingString, iString)==FALSE) \n      return(FALSE)\n  }\n  return(TRUE)\n}\n\n\nCheck_FileName_Contains_Strings = function(FileName, MultipleStrings2Check)\n  #This just wraps around StringContains_AllStrings with a name more fitting for the code so easier to read\n{\n  StringContains_AllStrings(FileName, MultipleStrings2Check)\n}\n\n\nGetFileName_ContainsStrings = function(FolderPath, Strings, WithPath)\n{\n  #Create a list of files at path\n  AllFileNames = list.files(FolderPath, full.names = WithPath)\n  \n  #cycle through list checking whether file contains the strings\n  for(iFileName in AllFileNames)\n  {\n    if(Check_FileName_Contains_Strings(iFileName,Strings))\n    {\n      return(iFileName)\n    }\n  }\n  \n}\n\n\nFileIsForACompareGroup = function(params, FILENAME){\n  nNotGroups2Compare=0\n  for (igroup in params$Groups2Plot){\n    if(!length(grep(igroup,FILENAME, fixed=TRUE))>0) nNotGroups2Compare = nNotGroups2Compare+1\n  }\n  if(length(params$Groups2Plot)==nNotGroups2Compare) {\n    return(FALSE)\n  } else {\n    return(TRUE)\n  }\n}\n\nFileIsForACompareGroupFleet = function(params, FILENAME){\n  FILENAME = paste(FILENAME,\".csv\", sep=\"\")\n  for (igroup in params$Groups2Plot){\n    if(length(grep(igroup,FILENAME, fixed=TRUE))>0) {\n      for (iFleet in params$Fleets2Plot){\n        if(iFleet==\"AllFleets\" && length(grep(\"AllFleets\",FILENAME, fixed=TRUE))>0) {\n          #browser()\n          return (TRUE)\n        }\n        if(length(grep(paste(iFleet,\".csv\", sep=''),FILENAME, fixed=TRUE))>0) {\n          #browser()\n          return (TRUE)\n        }\n      }\n    }\n  }\n  return (FALSE)\n}\n\nNumberOfValsNotNA = function(object.to.check, STRAT){\n  \n  return(sum(object.to.check[object.to.check$Strategy %in% STRAT,6:ncol(object.to.check)]!=-9999))\n  \n}\n",
    "created" : 1494401269445.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4263027198",
    "id" : "B71BB102",
    "lastKnownWriteTime" : 1494507567,
    "last_content_update" : 1494507567669,
    "path" : "C:/Users/Mark/Desktop/Desktop etc/GAP/MSE_Plugin_Results_Plotting/share_tools.R",
    "project_path" : "share_tools.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}