{
    "collab_server" : "",
    "contents" : "ResampleNPois = function(N)\n\n  {\n\n  tot1 = 0\n\n  for (i in 1:N)\n    {\n    print(paste(\"Iteration \", i))\n    ptm=proc.time()\n    temp = Sep2DataPois()\n    tot1 = tot1 + temp\n    print(proc.time()-ptm)\n\n    }\n\n  av1 = tot1/N\n\n\n  list(av1)\n\n  }\n\nSep2DataPois = function()\n\n  {\n\nlibrary(MASS)\n\n# Input file\n\tScaleInput = read.table(file=\"M:/My Documents/Hierachical Model/Data/Modelling_Datasets/Area_Boundaries/ASCII/input_bound.txt\",\n\t\t\t\t\t\tsep=\" \", na.strings = \"-9999\", skip = 6)\n\tScaleInput = as.matrix(ScaleInput)\n\n# Create Valid Scale 5 Matrix\n\tScale5 = matrix(nrow = 32, ncol = 96)\n\n\tfor(x in 1:96)\n\t\t{\n\t\tfor(y in 1:32)\n\t\t\t{\n\t\t\tScale5[y,x] = sum(ScaleInput[((y-1)*16+1):(y*16),((x-1)*16+1):(x*16)])\n\t\t\t}\n\t\t}\n\n\t# Setup input variables\n\tInputEntire = read.table(file=paste(\"M:/My Documents/Hierachical Model/Data/Modelling_Datasets/ASCII/otter.txt\", sep=\"\"), sep=\" \", na.strings = \"-9999\", skip = 6)\n\tscale=5\n\tInputEntire = as.matrix(InputEntire)\n\tNum_Y = dim(InputEntire)[1]\n\tNum_X = dim(InputEntire)[2]\n\tEntireRegion = InputEntire[1:Num_Y, 1:(Num_X-1)]\n\tif(scale==4) {ValidRegion = Scale4}\n\tif(scale==5) {ValidRegion = Scale5}\n\tif(scale==6) {ValidRegion = Scale6}\n\tif(scale==7) {ValidRegion = Scale7}\n\tNum_X = Num_X\n\tValidRegion = as.matrix(ValidRegion)\n\tEntireRegion[is.na(EntireRegion)] = 0\n\n\tEntireRegion = EntireRegion[,1:96] + ValidRegion[,1:96]\n\tChunk1 = EntireRegion[1:Num_Y, 1:Num_Y]\n\tChunk2 = EntireRegion[1:Num_Y, (Num_Y+1):(Num_Y*2)]\n\tChunk3 = EntireRegion[1:Num_Y, (Num_Y*2+1):(Num_Y*3)]\n\n  NumberRows = dim(EntireRegion)[1]\n  NumberCols = dim(EntireRegion)[2]\n\n  DataA = EntireRegion\n\n  #Count the number of points\n  NumberPoints = sum(DataA[!is.na(DataA)])\n  NumberPointsHalf = round(NumberPoints/2)\n  PointsLeft = NumberPoints\n\n  #this goes through the dataset randomly deleting values until creates half a dataset\n  for(i in 1:NumberPointsHalf)\n    {\n    pointdelete = round(runif(1,1,PointsLeft))\n    PointsLeft = PointsLeft-1\n\n    x=1\n    y=1\n    count=0\n    found=FALSE\n    while (found==FALSE)\n      {\n     # print(\"x=\")\n     # print(x)\n     # print(\"y=\")\n     # print(y)\n      if(!is.na(DataA[y,x]))\n        {\n        count = count + DataA[y,x]\n        }\n      if (count>=pointdelete)\n        {\n        found=TRUE\n        DataA[y,x] = DataA[y,x]-1\n        }\n      if(x<NumberCols)\n        {\n        x = x+1\n        }\n      else\n        {\n        x = 1\n        y = y+1\n        }\n      }\n\n    }\n    \n  #creates the second dataset as the difference between orig and first dataset\n  DataB = EntireRegion - DataA\n  DataA\n  OutputPois = cfwptest(DataA)\n\n  #Calc difference between predicted using fixed grid size and actual\n  TotNoCells = length(OutputPois[!is.na(OutputPois)])\n  squarediff = (OutputPois-DataB)^2\n  diffres1by1 = sqrt(sum(squarediff[!is.na(squarediff)])/TotNoCells)\n  \n  diffres1by1\n\n#       square = DataA[(y*4-3):(y*4),(x*4-3):(x*4)]\n#       average = mean(square[!is.na(square)])\n#       res4by4[(y*4-3):(y*4),(x*4-3):(x*4)] = average\n\n#  squarediff = (res4by4-DataB)^2\n#  TotNoCells = length(squarediff[!is.na(squarediff)])\n#  diffres4by4 = sqrt(sum(squarediff[!is.na(squarediff)])/TotNoCells)\n\n  #list(diffres1by1,diffres2by2,diffres4by4, diffres8by8, diffres16by16, diffres32by32)\n\n  }\n  \ncfwptest = function(InputEntire)\n\t{\n\n # \tlibrary(MASS)\n\n# Input file\n#\tScaleInput = read.table(file=\"M:/My Documents/Hierarchical Model/Data/Modelling_Datasets/Area_Boundaries/ASCII/input_bound.txt\",\n#\t\t\t\t\t\tsep=\" \", na.strings = \"-9999\", skip = 6)\n#\tScaleInput = as.matrix(ScaleInput)\n\n# Create Valid Scale 5 Matrix\n#\tScale5 = matrix(nrow = 32, ncol = 96)\n\n#\tfor(x in 1:96)\n#\t\t{\n#\t\tfor(y in 1:32)\n#\t\t\t{\n#\t\t\tScale5[y,x] = sum(ScaleInput[((y-1)*16+1):(y*16),((x-1)*16+1):(x*16)])\n#\t\t\t}\n#\t\t}\n\n# Setup input variables\n\t#InputEntire = read.table(file=paste(\"e:/mark/modelling_datasets/ascii/\", fname, \".txt\", sep=\"\"), sep=\" \", na.strings = \"-9999\", skip = 6)\n\n\tNum_Y = dim(InputEntire)[1]\n\tNum_X = dim(InputEntire)[2]\n\tEntireRegion = InputEntire\n#\tValidRegion = Scale5\n\n\t#ValidRegion = as.matrix(ValidRegion)\n\t#EntireRegion[is.na(EntireRegion)] = 0\n\t#EntireRegion = EntireRegion + ValidRegion\n\tChunk1 = EntireRegion[1:Num_Y, 1:Num_Y]\n\tChunk2 = EntireRegion[1:Num_Y, (Num_Y+1):(Num_Y*2)]\n\tChunk3 = EntireRegion[1:Num_Y, (Num_Y*2+1):(Num_Y*3)]\n\n# Setup output array\n# c[,,1] contains \"mean\"\n# c[,,2] contains \"level\"\n# c[,,3] contains \"type of fit\" where 1=poisson, 2=all zeros, 3=NA, 4=Average (4 is obsolete)\n\tEntireMat = array(dim=c(Num_Y,Num_X,3))\n\n# Setup free variable to hold total AIC\n\tEvalAIC <<- 0\n\n# Setup free variable to count the number of patches\n\tNoPatches <<- 0\n\n# Send each chunk to have a distribution fitted\n\tEntireMat[1:Num_Y, 1:Num_Y,] = cfptest(Chunk1, 0)\n\tEntireMat[1:Num_Y, (Num_Y+1):(Num_Y*2),] = cfptest(Chunk2,0)\n\tEntireMat[1:Num_Y, (Num_Y*2+1):(Num_Y*3),] = cfptest(Chunk3,0)\n\n# Create files\n  #scale_header = read.table(file=paste(\"e:/mark/modelling_datasets/area_boundaries/scale/scale\", scale, \".txt\", sep=\"\"), sep=\"/\")\n\t#write.table(scale_header, quote=F, file=paste(\"e:/Mark/Modelled_Results/Poisson/ASCII/\", fname, \"_mean.txt\", sep=\"\"), row.names=FALSE, col.names=FALSE)\n\t#write.table(scale_header, quote=F, file=paste(\"e:/Mark/Modelled_Results/Poisson/ASCII/\", fname, \"_lev.txt\", sep=\"\"), row.names=FALSE, col.names=FALSE)\n\t#write.table(scale_header, quote=F, file=paste(\"e:/Mark/Modelled_Results/Poisson/ASCII/\", fname, \"_type.txt\", sep=\"\"), row.names=FALSE, col.names=FALSE)\n\n  EntireMat[,,1]\n\t#write.table(EntireMat[,,1], file=paste(\"e:/Mark/Modelled_Results/Poisson/ASCII/\", fname, \"_mean.txt\", sep=\"\"), append = T, na=\"-9999\", row.names=FALSE, col.names=FALSE)\n\t#write.table(EntireMat[,,2], file=paste(\"e:/Mark/Modelled_Results/Poisson/ASCII/\", fname, \"_lev.txt\", sep=\"\"), append = T, na=\"-9999\", row.names=FALSE, col.names=FALSE)\n\t#write.table(EntireMat[,,3], file=paste(\"e:/Mark/Modelled_Results/Poisson/ASCII/\", fname, \"_type.txt\", sep=\"\"), append = T, na=\"-9999\", row.names=FALSE, col.names=FALSE)\n\n\t#print(\"No of Patches:\")\n\t#print(NoPatches)\n\t}\n\n#------------------------------------------------------------------------------------------------------------------------\n#************************************************************************************************************************\n# Function to compare the goodness of fit of distribution for upper window with quarter windows\n#************************************************************************************************************************\n#------------------------------------------------------------------------------------------------------------------------\n\ncfptest = function(UpperWin, Lev)\n\t{\n\n#------------------------------------------------------------------------------------------------------------------------\n# Setup Variables\n\n# Set maximum level\n\tMaxLev = 7\n\n# Get the size of upperwindow\n\tif(is.matrix(UpperWin))\n\t\t{\n\t\tDimWin = dim(UpperWin)[1]\n\t\t}\n\telse\n\t\t{\n\t\tDimWin = 1\n\t\t}\n\n# Setup matrix for output\n\tOutput = array(dim=c(DimWin, DimWin, 3))\n\tLev[] = Lev[] + 1\n\n#------------------------------------------------------------------------------------------------------------------------\n# If entirely NA then return NA\n\n\tif(sum(!is.na(UpperWin))==0)\n\t\t{\n\t\tOutput[] = NA\n\t\tOutput[,,3] = 3\n\t\treturn(Output)\n\t\t}\n\n#------------------------------------------------------------------------------------------------------------------------\n# If 1x1 and not NA\n#\n#\tif(dim(UpperWin)[1]==1 & sum(is.na(UpperWin))==0)\n#\t\t{\n#\t\tOutput[,1] = UpperWin[1,1]\n#\t\tOutput[,2] = Lev\n#\t\tOutput[,3] = 1\n#\t\tNoPatches = NoPatches + 1\n#\t\treturn(Output)\n#\t\t}\n\n#------------------------------------------------------------------------------------------------------------------------\n# If 1x1 and is NA\n\n\tif(DimWin==1 & sum(is.na(UpperWin))==1)\n\t\t{\n\t\tprint(\"block executed conditional on 1x1 and being NA\")\n\t\tOutput[] = NA\n\t\tOutput[,,3] = 3\n\t\treturn(Output)\n\t\t}\n\n\n#------------------------------------------------------------------------------------------------------------------------\n# If 1x1 and zero\n\n\tif(DimWin==1)\n\t\t{\n\t\tif(UpperWin==0)\n\t\t\t{\n\t\t\tOutput[,,1] = 0\n\t\t\tOutput[,,2] = Lev\n\t\t\tOutput[,,3] = 2\n\t\t\t}\n\t\t}\n\n#------------------------------------------------------------------------------------------------------------------------\n# If 1x1 and not zero\n\n#\tif(DimWin==1 & as.vector(UpperWin)>0)\n#\t\t{\n#\t\tOutput[,,1] = as.vector(UpperWin)\n#\t\tOutput[,,2] = Lev\n#\t\tOutput[,,3] = 1\n#\t\t}\n\n#------------------------------------------------------------------------------------------------------------------------\n# If 2x2 and some values NA return NA\n#\tif(dim(UpperWin)[1]==2 & sum(is.na(UpperWin))>0)\n#\t\t{\n#\t\tOutput[1,1,1] = UpperWin[1,1]\n#\t\tOutput[1,2,1] = UpperWin[1,2]\n#\t\tOutput[2,1,1] = UpperWin[2,1]\n#\t\tOutput[2,2,1] = UpperWin[1,1]\n#\t\tOutput[,,3] = 3\n#\t\treturn(Output)\n#\t\t}\n#\n#------------------------------------------------------------------------------------------------------------------------\n# If 2x2 return mean\n#\tif(dim(UpperWin)[1]==2)\n#\t\t{\n#\t\tOutput[,,1] = mean(UpperWin)\n#\t\tOutput[,,2] = Lev\n#\t\tOutput[,,3] = 4\n#\t\treturn(Output)\n#\t\t}\n\n#------------------------------------------------------------------------------------------------------------------------\n# If some cells are NA and then send 1/4's to compare fit\n\tif(sum(is.na(UpperWin))>0 & sum(!is.na(UpperWin))>0)\n\t\t{\n\t\tOutput[1:(DimWin/2), 1:(DimWin/2),] = cfptest(UpperWin[1:(DimWin/2), 1:(DimWin/2)], Lev)\n\t\tOutput[(DimWin/2+1):DimWin, 1:(DimWin/2),] = cfptest(UpperWin[(DimWin/2+1):DimWin, 1:(DimWin/2)], Lev)\n\t\tOutput[1:(DimWin/2), (DimWin/2+1):DimWin,] = cfptest(UpperWin[1:(DimWin/2), (DimWin/2+1):DimWin], Lev)\n\t\tOutput[(DimWin/2+1):DimWin, (DimWin/2+1):DimWin,] = cfptest(UpperWin[(DimWin/2+1):DimWin, (DimWin/2+1):DimWin], Lev)\n\t\t}\n\n#------------------------------------------------------------------------------------------------------------------------\n#------------------------------------------------------------------------------------------------------------------------\n# If all cells numeric then fit upper window and 1/4 windows and compare\n\tif(sum(is.na(UpperWin))==0)\n\t\t{\n\n# If all values equal zero in upper window then return zero\n\t\tif(mean(as.vector(UpperWin))==0)\n\t\t\t{\n\t\t\tOutput[,,1] = 0\n\t\t\tOutput[,,2] = Lev\n\t\t\tOutput[,,3] = 2\n\t\t\treturn(Output)\n\t\t\t}\n\n#------------------------------------------------------------------------------------------------------------------------\n# Fit UpperWin\n#if (DimWin==1){browser()}\n\n\t\tUpperPois = fitdistr(as.vector(UpperWin), \"Poisson\")\n\t\tif(DimWin==1)\n      {\n      #print(\"Fitted a Poisson to a 1x1\")\n      }\n\t\tUpperAIC = AIC(UpperPois)\n\n#------------------------------------------------------------------------------------------------------------------------\n# If quarters too small to fit then send result of upper window\n\n\t\tif(DimWin==1)\n\t\t\t{\n\t\t\tOutput[,,1] = UpperPois$estimate\n\t\t\tOutput[,,2] = Lev\n\t\t\tOutput[,,3] = 1\n\t\t\tEvalAIC <<- EvalAIC + UpperAIC\n\t\t\tNoPatches <<- NoPatches + 1\n\t\t\treturn(Output)\n\t\t\t}\n\n#------------------------------------------------------------------------------------------------------------------------\n# Setup variables with each quarter\n\n\t\tQuarter1 = as.vector(UpperWin[1:(DimWin/2), 1:(DimWin/2)])\n\t\tQuarter2 = as.vector(UpperWin[(DimWin/2+1):DimWin, 1:(DimWin/2)])\n\t\tQuarter3 = as.vector(UpperWin[1:(DimWin/2), (DimWin/2+1):DimWin])\n\t\tQuarter4 = as.vector(UpperWin[(DimWin/2+1):DimWin, (DimWin/2+1):DimWin])\n\n#------------------------------------------------------------------------------------------------------------------------\n# Fit poisson to each quarter\n\n\t\tPois1 = fitdistr(Quarter1, \"poisson\")\n\t\tPois2 = fitdistr(Quarter2, \"poisson\")\n\t\tPois3 = fitdistr(Quarter3, \"poisson\")\n\t\tPois4 = fitdistr(Quarter4, \"poisson\")\n\n#------------------------------------------------------------------------------------------------------------------------\n# Calculate lower AIC value\n\n\t\tComLogLik = logLik(Pois1)+logLik(Pois2)+logLik(Pois3)+logLik(Pois4)\n\t\tLowerAIC = 2*4 - 2*ComLogLik\n\n#------------------------------------------------------------------------------------------------------------------------\n# If UpperAIC is better than LowerAIC return values for upper fit\n\n\t\tif(UpperAIC<LowerAIC)\n\t\t\t{\n\t\t\tOutput[,,1]=UpperPois$estimate\n\t\t\tOutput[,,2]=Lev\n\t\t\tOutput[,,3]=1\n\t\t\tEvalAIC <<- EvalAIC + UpperAIC\n\t\t\tNoPatches <<- NoPatches + 1\n\t\t\treturn(Output)\n\t\t\t}\n\n#------------------------------------------------------------------------------------------------------------------------\n# If UpperAIC is worse than LowerAIC send quarters for comparison\n\n\t\tif(UpperAIC>=LowerAIC & Lev<=MaxLev)\n \t\t\t{\n\t\t\tOutput[1:(DimWin/2), 1:(DimWin/2),] = cfptest(UpperWin[1:(DimWin/2), 1:(DimWin/2)], Lev)\n\t\t\tOutput[(DimWin/2+1):DimWin, 1:(DimWin/2),] = cfptest(UpperWin[(DimWin/2+1):DimWin, 1:(DimWin/2)], Lev)\n\t\t\tOutput[1:(DimWin/2), (DimWin/2+1):DimWin,] = cfptest(UpperWin[1:(DimWin/2), (DimWin/2+1):DimWin], Lev)\n\t\t\tOutput[(DimWin/2+1):DimWin, (DimWin/2+1):DimWin,] = cfptest(UpperWin[(DimWin/2+1):DimWin, (DimWin/2+1):DimWin], Lev)\n\t\t\t}\n\t\t}\n\treturn(Output)\n\n}\n",
    "created" : 1480235704475.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1684617151",
    "id" : "AEA5A79",
    "lastKnownWriteTime" : 1317989282,
    "last_content_update" : 1317989282,
    "path" : "X:/Work/Fisheries Science/Hiearchical Project/Tools/CreateRandom2DatasetsPois.r",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}